#!/usr/bin/env ruby

# Try to load external libs, helpers and constants
begin
  LIB_DIR = File.expand_path(File.dirname(__FILE__) + "/../lib/")
  require "rubygems"
  require "optparse"
  require 'tempfile'
  require "#{LIB_DIR}/constants"
  require "#{LIB_DIR}/cli"
  require "#{LIB_DIR}/git"
  require "#{LIB_DIR}/docker"
rescue LoadError => e
  raise "EXITING: some basic libs were not found (#{e.message})"
end
include Helpers


# Some helpers
def output_lines popen
  popen.read.lines.map(&:strip)
end

def run_cmd command, title
  puts "* #{title}"
  puts command
  system command
  puts
end


# Handle configuration
begin
  # Defaults
  opt_tag       = nil
  opt_latest    = false
  opt_push      = false
  opt_list_tags = false

  # Parse options and check compliance
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: #{File.basename $PROGRAM_NAME} [options] start|stop"
    opts.on("",   "--tags", "List all available tags")        { |value| opt_list_tags = true  }
    opts.on("-t",   "--tag VERSION")                          { |value| opt_tag = value.to_s  }
    opts.on("-l",   "--latest", "Tag build with :latest")     { |value| opt_latest = true     }
    opts.on("-p",   "--push",   "Push the build(s)")          { |value| opt_push = true       }
    opts.on_tail("-h", "--help", "Show this message")  do
      puts opts
      exit
    end

  end
  parser.order!(ARGV)

rescue OptionParser::InvalidOption => e
  abort "EXITING: InvalidOption: #{e.message}"
rescue StandardError => e
  abort "EXITING: StandardError: #{e.message}"
end


# Check tag validiy
available_tags = Git.fetch_tags
if opt_list_tags
  end_with_tags = "please specify tag to build"
elsif !opt_tag
  end_with_tags = "please specify tag to build"
elsif available_tags.include? opt_tag
  end_with_tags = "the specified tag [#{opt_tag}] not found"
else
  end_with_tags = "all good"
end
if end_with_tags || true
  puts "EXITING: tag: #{end_with_tags}"
  Git.list_tags available_tags
  exit 1
end


# Prepare some context vars
temp_archive    = "dockerize-archive-#{opt_tag}.tar"
release_name    = "#{DOCKER_REPO}:#{opt_tag}"
release_latest  = "#{DOCKER_REPO}:latest"

# Prepare commands
cmd_archive     = Git.cmd_archive temp_archive, opt_tag
cmd_build       = Docker.cmd_build temp_archive, release_name
cmd_tag         = Docker.cmd_tag release_name, release_latest
opt_push        = Docker.cmd_push release_name
opt_push_latest = Docker.cmd_push release_latest


# Config summary
puts "--- DOCKERIZE CONFIG"
puts "Git tag            #{opt_tag}"
puts "Use latest tag     #{opt_latest}"
puts "Code archive       #{temp_archive}"
puts


# Checkout tag code in temp archive
run_cmd cmd_archive, "Creating code archive"
archive_size = File.size(temp_archive)
puts "> archive size: #{archive_size}"

# Build docker image from that archive
run_cmd cmd_build, "Building docker image"

# Tag latest if required
if opt_latest
  run_cmd cmd_tag, "Updating tag [#{release_latest}] to point to [#{release_name}]"
  opt_push += " && #{opt_push_latest}" if opt_latest
end

# Push releases
run_cmd opt_push, "Pushing releases" if opt_push


# $?.exitstatus
puts "* We're all set !"
exit 0
